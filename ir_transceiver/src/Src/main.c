/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdio.h>
#include "stm32fxx.h"
#include "lcd_driver.h"
#include "keypad_driver.h"

void USART_TX_INIT(void);
void USART_RX_INIT(void);
void USART_GPIO_INIT(void);
void delay(uint32_t num);

USART_Handle_t usart_handle_tx, usart_handle_rx;

int main(void)
{
	Keypad_Init();
	LCD_Init();

	USART_GPIO_INIT();
	USART_TX_INIT();
	USART_RX_INIT();

	uint8_t msg_tx[1], msg_rx[1];

	while(1)
	{
		// TX ROUTINE: Send keypad data to TX pin
		msg_tx[0] = Keypad_Scan();
		while(USART_SendDataIT(&usart_handle_tx, (uint8_t*)msg_tx, 1) != USART_READY);
		USART_SendData(&usart_handle_tx, (uint8_t*)msg_tx, 1);

		// RX ROUTINE: Send RX data to LCD
		while(USART_ReceiveDataIT(&usart_handle_rx, (uint8_t*)msg_rx, 1) != USART_READY);
		USART_ReceiveData(&usart_handle_rx, (uint8_t*)msg_rx, 1);
		LCD_Data((uint8_t*)msg_rx);
	}

	return 0;
}


void USART_TX_INIT(void)
{
	// Set for TX
	USART_PeriClockControl(USART2, ENABLE);

	usart_handle_tx.pUSARTx = USART2;
	usart_handle_tx.USART_Config.USART_Baud = USART_STD_BAUD_1200;
	usart_handle_tx.USART_Config.USART_HWFlowControl = USART_HW_FLOW_CTRL_NONE;
	usart_handle_tx.USART_Config.USART_Mode = USART_MODE_TX;
	usart_handle_tx.USART_Config.USART_StopBitNum = USART_STOPBITS_1;
	usart_handle_tx.USART_Config.USART_WordLength = USART_WORDLENGTH_8;
	usart_handle_tx.USART_Config.USART_ParityControl = USART_PARITY_DISABLE;
	USART_Init(&usart_handle_tx);

	USART_IRQInterruptConfig(IRQ_NUM_USART2, ENABLE);
	USART_IRQHandling(&usart_handle_tx);
	USART_PeripheralControl(USART2, ENABLE);
}


void USART_RX_INIT(void)
{
	// Set for RX
	USART_PeriClockControl(USART3, ENABLE);

	usart_handle_rx.pUSARTx = USART3;
	usart_handle_rx.USART_Config.USART_Baud = USART_STD_BAUD_1200;
	usart_handle_rx.USART_Config.USART_HWFlowControl = USART_HW_FLOW_CTRL_NONE;
	usart_handle_rx.USART_Config.USART_Mode = USART_MODE_RX;
	usart_handle_rx.USART_Config.USART_StopBitNum = USART_STOPBITS_1;
	usart_handle_rx.USART_Config.USART_WordLength = USART_WORDLENGTH_8;
	usart_handle_rx.USART_Config.USART_ParityControl = USART_PARITY_DISABLE;
	USART_Init(&usart_handle_rx);

	USART_IRQInterruptConfig(IRQ_NUM_USART3, ENABLE);
	USART_IRQHandling(&usart_handle_rx);
	USART_PeripheralControl(USART3, ENABLE);
}


void USART_GPIO_INIT(void)
{
	GPIO_Handle_t usart_gpio;

	GPIO_PeriClockControl(GPIOA, ENABLE);

	usart_gpio.pGPIOx = GPIOA;
	usart_gpio.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALT_FN;
	usart_gpio.GPIO_PinConfig.GPIO_PinOType = GPIO_OUTTYPE_PP;
	usart_gpio.GPIO_PinConfig.GPIO_PinPUPDControl = GPIO_PIN_PU;
	usart_gpio.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_HIGH;
	usart_gpio.GPIO_PinConfig.GPIO_PinAltFuncMode = 7;

	// USART TX
	usart_gpio.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NUM_2;
	GPIO_Init(&usart_gpio);

	// USART RX
	usart_gpio.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NUM_3;
	GPIO_Init(&usart_gpio);
}


void delay(uint32_t num)
{
	// Delay in ms
	for(; num > 0; num--)
	{
		for(uint32_t i = 0; i < 3195; i++);
	}
}
